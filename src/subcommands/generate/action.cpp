#include "catalyst/hooks.hpp"
#include "catalyst/log-utils/log.hpp"
#include "catalyst/subcommands/generate.hpp"
#include "catalyst/yaml-utils/Configuration.hpp"
#include "yaml-cpp/node/node.h"

#include <expected>
#include <filesystem>
#include <fstream>
#include <stdexcept>
#include <string>
#include <sys/wait.h>
#include <unordered_set>
#include <vector>
#include <yaml-cpp/yaml.h>

namespace catalyst::generate {
namespace fs = std::filesystem;

void write_variables(const catalyst::YAML_UTILS::Configuration &config,
                     catalyst::generate::BuildWriters::BaseWriter &writer,
                     const std::vector<std::string> &enabled_features);
void write_rules(catalyst::generate::BuildWriters::BaseWriter &writer);
std::vector<std::string> intermediate_targets(catalyst::generate::BuildWriters::BaseWriter &writer,
                                              const std::unordered_set<fs::path> &source_set);
void final_target(const YAML_UTILS::Configuration &config,
                  const auto &object_files,
                  catalyst::generate::BuildWriters::BaseWriter &writer);

std::expected<void, std::string> action(const parse_t &parse_args) {
    catalyst::logger.log(LogLevel::DEBUG, "Generate subcommand invoked.");

    catalyst::logger.log(LogLevel::DEBUG, "Composing profiles.");
    YAML_UTILS::Configuration config;

    try {
        config = YAML_UTILS::Configuration(parse_args.profiles);
    } catch (std::runtime_error &err) {
        return std::unexpected(err.what());
    }

    catalyst::logger.log(LogLevel::DEBUG, "Running pre-generate hooks.");
    if (auto res = hooks::pre_generate(config); !res) {
        catalyst::logger.log(LogLevel::ERROR, "Pre-generate hook failed: {}", res.error());
        return res;
    }

    fs::path current_dir = fs::current_path();
    std::vector<std::string> relative_source_dirs, absolute_source_dirs;
    if (auto res = config.get_string_vector("manifest.dirs.source"); !res) {
        return std::unexpected("Unable to get value for manifest.dirs.source");
    } else {
        relative_source_dirs = res.value();
        for (const auto &dir : relative_source_dirs)
            absolute_source_dirs.push_back((current_dir / dir).string());
    }

    catalyst::logger.log(LogLevel::DEBUG, "Building source set.");
    auto source_set_res = build_source_set(absolute_source_dirs, parse_args.profiles);
    if (!source_set_res) {
        catalyst::logger.log(LogLevel::ERROR, "Failed to build source set: {}", source_set_res.error());
        return std::unexpected(source_set_res.error());
    }

    std::unordered_set<std::filesystem::path> source_set = source_set_res.value();

    fs::path build_dir = config.get_string("manifest.dirs.build").value();
    fs::path obj_dir = build_dir / "obj";

    catalyst::logger.log(LogLevel::DEBUG, "Creating object directory: {}", obj_dir.string());
    fs::create_directories(obj_dir);
    if (!fs::exists(obj_dir) || !fs::is_directory(obj_dir)) {
        catalyst::logger.log(LogLevel::ERROR, "Failed to create object directory: {}", obj_dir.string());
        return std::unexpected("Failed to create object directory: " + obj_dir.string());
    }

    std::string generator = config.get_string("meta.generator").value_or("cbe");
    std::string build_filename = (generator == "ninja") ? "build.ninja" : "catalyst.build";

    const fs::path buildfile_path = build_dir / build_filename;
    catalyst::logger.log(LogLevel::DEBUG, "Writing build file to: {}", buildfile_path.string());
    std::ofstream buildfile{buildfile_path};

    if (!buildfile) {
        return std::unexpected(std::format("Failed to open {} for writing", buildfile_path.string()));
    }

    auto generate_build = [&](BuildWriters::BaseWriter &writer) {
        writer.add_comment("Build file generated by Catalyst");
        write_variables(config, writer, parse_args.enabled_features);
        write_rules(writer);
        std::vector<std::string> object_files = intermediate_targets(writer, source_set);
        final_target(config, object_files, writer);
    };

    if (generator == "ninja") {
        BuildWriters::DerivedWriter<BuildWriters::TargetType::Ninja> writer(buildfile);
        generate_build(writer);
    } else {
        BuildWriters::DerivedWriter<BuildWriters::TargetType::CBE> writer(buildfile);
        generate_build(writer);
    }

    catalyst::logger.log(
        LogLevel::DEBUG, "Writing profile composition to: {}", (build_dir / "profile_composition.yaml").string());
    std::ofstream profile_comp_file{build_dir / "profile_composition.yaml"};
    if (!profile_comp_file) {
        return std::unexpected("Failed to open profile_composition.yaml for writing in " + build_dir.string());
    }
    profile_comp_file << config.get_root();

    catalyst::logger.log(LogLevel::DEBUG, "Running post-generate hooks.");
    if (auto res = hooks::post_generate(config); !res) {
        catalyst::logger.log(LogLevel::ERROR, "Post-generate hook failed: {}", res.error());
        return res;
    }
    catalyst::logger.log(LogLevel::DEBUG, "Generate subcommand finished successfully.");
    return {};
}

std::vector<std::string> intermediate_targets(catalyst::generate::BuildWriters::BaseWriter &writer,
                                              const std::unordered_set<std::filesystem::path> &source_set) {
    catalyst::logger.log(LogLevel::DEBUG, "Generate subcommand invoked.");
    fs::path current_dir = fs::current_path();
    writer.add_comment("Source File Compilation");
    std::vector<std::string> object_files;
    for (const auto &src : source_set) {
        fs::path relative_src_path = fs::relative(src, current_dir);
        std::string obj_name = relative_src_path.string();
        std::replace(obj_name.begin(), obj_name.end(), '/', '_');
        std::replace(obj_name.begin(), obj_name.end(), '\\', '_'); // For Windows paths
        obj_name = obj_name.substr(0, obj_name.find_last_of('.')) + ".o";
        object_files.push_back((fs::path{"obj"} / obj_name).string());
        writer.add_build({object_files.back()},
                         ((src.extension() == ".c" || src.extension() == ".cu") ? "cc_compile" : "cxx_compile"),
                         {src.string()});
    }
    return object_files;
}

void final_target(const YAML_UTILS::Configuration &config,
                  const auto &object_files,
                  catalyst::generate::BuildWriters::BaseWriter &writer) {
    catalyst::logger.log(LogLevel::DEBUG, "Generating final target.");
    // Build edge for the final target
    std::string type = config.get_string("manifest.type").value_or("BINARY");
    std::string target_prefix, target_suffix, link_rule;

    if (type == "STATICLIB") {
        link_rule = "static_link";
#if defined(_WIN32)
        target_prefix = "";
        target_suffix = ".lib";
#else
        target_prefix = "lib";
        target_suffix = ".a";
#endif
    } else if (type == "SHAREDLIB") {
        link_rule = "shared_link";
#if defined(_WIN32)
        target_prefix = "";
        target_suffix = ".dll";
#elif defined(__APPLE__)
        target_prefix = "lib";
        target_suffix = ".dylib";
#else // Linux and other Unix-likes
        target_prefix = "lib";
        target_suffix = ".so";
#endif
    } else { // BINARY or default
        link_rule = "binary_link";
#if defined(_WIN32)
        target_suffix = ".exe";
#endif
    }

    std::string target_name = config.get_string("manifest.name").value_or("name");
    fs::path target_path{target_prefix + target_name + target_suffix};
    catalyst::logger.log(LogLevel::DEBUG, "Final target name: {}", target_path.string());
    writer.add_comment("Build edge for the final target");
    writer.add_build({target_path.string()}, link_rule, object_files);

    // Default target
    writer.add_comment("Default target to build");
    writer.add_default(target_path.string());
}

void write_variables(const catalyst::YAML_UTILS::Configuration &config,
                     catalyst::generate::BuildWriters::BaseWriter &writer,
                     const std::vector<std::string> &enabled_features) {

    catalyst::logger.log(LogLevel::DEBUG, "Writing variables to build file.");
    fs::path current_dir = fs::current_path();
    std::string build_dir_str = config.get_string("manifest.dirs.build").value_or("build");
    fs::path build_dir{build_dir_str};
    fs::path obj_dir = "obj";

    std::string cxxflags =
                    std::format("{} -DCATALYST_BUILD_SYS=1 -DCATALYST_PROJ_NAME=\"{}\" -DCATALYST_PROJ_VER=\"{}\"",
                                config.get_string("manifest.tooling.CXXFLAGS").value_or(""),
                                config.get_string("manifest.name").value_or("name"),
                                config.get_string("manifest.version").value_or("0.0.0")),
                ccflags =
                    std::format("{} -DCATALYST_BUILD_SYS=1 -DCATALYST_PROJ_NAME=\"{}\" -DCATALYST_PROJ_VER=\"{}\"",
                                config.get_string("manifest.tooling.CCFLAGS").value_or(""),
                                config.get_string("manifest.name").value_or("name"),
                                config.get_string("manifest.version").value_or("0.0.0")),
                ldflags = "-Lcatalyst-libs";

    if (const char *vcpkg_root = std::getenv("VCPKG_ROOT"); vcpkg_root != nullptr) {
#if defined(_WIN32)
        const char *triplet = "x64-windows";
#elif defined(__APPLE__)
        const char *triplet = "x64-osx";
#else
        const char *triplet = "x64-linux";
#endif
        cxxflags += std::format(" -I{}", (fs::path(vcpkg_root) / "installed" / triplet / "include").string());
        ccflags += std::format(" -I{}", (fs::path(vcpkg_root) / "installed" / triplet / "include").string());
        ldflags += std::format(" -L{}", (fs::path(vcpkg_root) / "installed" / triplet / "lib").string());
    } else {
        logger.log(LogLevel::WARN, "VCPKG_ROOT environment variable is not defined.");
    }

    if (const auto &features_node = config.get_root()["features"]; features_node && features_node.IsSequence()) {
        for (const auto &feature_map : features_node) {
            if (feature_map.IsMap()) {
                for (auto it = feature_map.begin(); it != feature_map.end(); ++it) {
                    std::string feature = it->first.as<std::string>();
                    bool default_enabled = it->second.as<bool>();
                    bool explicitly_enabled =
                        std::find(enabled_features.begin(), enabled_features.end(), feature) != enabled_features.end();
                    bool explicitly_disabled =
                        std::find(enabled_features.begin(), enabled_features.end(), "no-" + feature) !=
                        enabled_features.end();

                    bool is_enabled = default_enabled;
                    if (explicitly_enabled) {
                        is_enabled = true;
                    } else if (explicitly_disabled) {
                        is_enabled = false;
                    }

                    std::string flag = std::format(" -DFF_{}__{}={}",
                                                   config.get_string("manifest.name").value_or("name"),
                                                   feature,
                                                   is_enabled ? "1" : "0");
                    cxxflags += flag;
                    ccflags += flag;
                }
            }
            // reaching this is technically an error but we allow it
        }
    }

    std::vector<std::string> inc_dirs = config.get_string_vector("manifest.dirs.include").value();
    for (const auto &inc_dir : inc_dirs) {
        cxxflags += std::format(" -I{}", fs::absolute(inc_dir).string());
        ccflags += std::format(" -I{}", fs::absolute(inc_dir).string());
    }

    std::string ldlibs;
    for (const auto &dep : config.get_root()["dependencies"]) {
        if (auto res = find_dep(build_dir_str, dep); !res) {
            catalyst::logger.log(LogLevel::ERROR, "{}", res.error());
            continue;
        } else {
            auto [lib_path, inc_path, libs] = res.value();
            ldflags += " " + lib_path;
            ldlibs += " " + libs;
            ccflags += " " + inc_path;
            cxxflags += " " + inc_path;
        }
    }

    writer.add_comment("Variables");
    writer.add_variable("cc", config.get_string("manifest.tooling.CC").value_or("clang"));
    writer.add_variable("cxx", config.get_string("manifest.tooling.CXX").value_or("clang++"));
    writer.add_variable("cxxflags", cxxflags);
    writer.add_variable("cflags", ccflags);
    writer.add_variable("ldflags", ldflags);
    writer.add_variable("ldlibs", ldlibs); // place compiled libraries here
}

void write_rules(catalyst::generate::BuildWriters::BaseWriter &writer) {
    catalyst::logger.log(LogLevel::DEBUG, "Writing rules to build file.");
    writer.add_comment("Rules for compiling");
    writer.add_rule("cxx_compile", "$cxx $cxxflags -MMD -MF $out.d -c $in -o $out", "CXX $out", "$out.d", "gcc");
    writer.add_rule("cc_compile", "$cc $cflags -MMD -MF $out.d -c $in -o $out", "CC $out", "$out.d", "gcc");

    writer.add_comment("Rules for linking");
    writer.add_rule("binary_link", "$cxx $in -o $out $ldflags $ldlibs", "LINK $out");
    writer.add_rule("static_link", "ar rcs $out $in", "LINK $out");
    writer.add_rule("shared_link", "$cxx -shared $in -o $out", "LINK $out");
}
} // namespace catalyst::generate
