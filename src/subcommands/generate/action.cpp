#include <sys/wait.h>

#include <expected>
#include <filesystem>
#include <fstream>
#include <stdexcept>
#include <string>
#include <unordered_set>
#include <vector>

#include <yaml-cpp/yaml.h>

#include "catalyst/hooks.hpp"
#include "catalyst/utils/log/log.hpp"
#include "catalyst/subcommands/generate.hpp"
#include "catalyst/utils/yaml/configuration.hpp"

#include "yaml-cpp/node/node.h"

namespace catalyst::generate {
namespace fs = std::filesystem;

namespace {

void writeVariables(const catalyst::utils::yaml::Configuration &config,
                    catalyst::generate::buildwriters::BaseWriter &writer,
                    const std::vector<std::string> &enabled_features);
void writeRules(catalyst::generate::buildwriters::BaseWriter &writer);
std::vector<std::string> intermediateTargets(catalyst::generate::buildwriters::BaseWriter &writer,
                                             const std::unordered_set<fs::path> &source_set);
void finalTarget(const utils::yaml::Configuration &config,
                 const auto &object_files,
                 catalyst::generate::buildwriters::BaseWriter &writer);

} // namespace

std::expected<void, std::string> action(const Parse &parse_args) {
    catalyst::logger.log(LogLevel::DEBUG, "Generate subcommand invoked.");

    catalyst::logger.log(LogLevel::DEBUG, "Composing profiles.");
    utils::yaml::Configuration config;

    try {
        config = utils::yaml::Configuration(parse_args.profiles);
    } catch (std::runtime_error &err) {
        return std::unexpected(err.what());
    }

    catalyst::logger.log(LogLevel::DEBUG, "Running pre-generate hooks.");
    if (auto res = hooks::preGenerate(config); !res) {
        catalyst::logger.log(LogLevel::ERROR, "Pre-generate hook failed: {}", res.error());
        return res;
    }

    fs::path current_dir = fs::current_path();
    std::vector<std::string> relative_source_dirs;
    std::vector<std::string> absolute_source_dirs;
    auto source_dirs_res = config.getStringVector("manifest.dirs.source");
    if (!source_dirs_res) {
        return std::unexpected("Unable to get value for manifest.dirs.source");
    }
    relative_source_dirs = source_dirs_res.value();
    absolute_source_dirs.reserve(relative_source_dirs.size());
    for (const auto &dir : relative_source_dirs)
        absolute_source_dirs.push_back((current_dir / dir).string());

    catalyst::logger.log(LogLevel::DEBUG, "Building source set.");
    auto source_set_res = buildSourceSet(absolute_source_dirs, parse_args.profiles);
    if (!source_set_res) {
        catalyst::logger.log(LogLevel::ERROR, "Failed to build source set: {}", source_set_res.error());
        return std::unexpected(source_set_res.error());
    }

    std::unordered_set<std::filesystem::path> source_set = source_set_res.value();

    fs::path build_dir = config.getString("manifest.dirs.build").value();
    fs::path obj_dir = build_dir / "obj";

    catalyst::logger.log(LogLevel::DEBUG, "Creating object directory: {}", obj_dir.string());
    fs::create_directories(obj_dir);
    if (!fs::exists(obj_dir) || !fs::is_directory(obj_dir)) {
        catalyst::logger.log(LogLevel::ERROR, "Failed to create object directory: {}", obj_dir.string());
        return std::unexpected("Failed to create object directory: " + obj_dir.string());
    }

    std::string generator = parse_args.backend;
    if (generator.empty()) {
        generator = config.getString("meta.generator").value_or("cbe");
    }

    std::string build_filename;
    if (generator == "ninja") {
        build_filename = "build.ninja";
    } else if (generator == "gmake" || generator == "make") {
        build_filename = "Makefile";
    } else {
        build_filename = "catalyst.build";
    }

    const fs::path buildfile_path = build_dir / build_filename;
    catalyst::logger.log(LogLevel::DEBUG, "Writing build file to: {}", buildfile_path.string());
    std::ofstream buildfile{buildfile_path};

    if (!buildfile) {
        return std::unexpected(std::format("Failed to open {} for writing", buildfile_path.string()));
    }

    auto generate_build = [&](buildwriters::BaseWriter &writer) {
        writer.addComment("Build file generated by Catalyst");
        writeVariables(config, writer, parse_args.enabled_features);
        writeRules(writer);
        std::vector<std::string> object_files = intermediateTargets(writer, source_set);
        finalTarget(config, object_files, writer);
    };

    if (generator == "ninja") {
        buildwriters::DerivedWriter<buildwriters::TargetType::Ninja> writer(buildfile);
        generate_build(writer);
    } else if (generator == "gmake" || generator == "make") {
        buildwriters::DerivedWriter<buildwriters::TargetType::Make> writer(buildfile);
        generate_build(writer);
    } else {
        buildwriters::DerivedWriter<buildwriters::TargetType::CBE> writer(buildfile);
        generate_build(writer);
    }

    catalyst::logger.log(
        LogLevel::DEBUG, "Writing profile composition to: {}", (build_dir / "profile_composition.yaml").string());
    std::ofstream profile_comp_file{build_dir / "profile_composition.yaml"};
    if (!profile_comp_file) {
        return std::unexpected("Failed to open profile_composition.yaml for writing in " + build_dir.string());
    }
    profile_comp_file << config.getRoot();

    catalyst::logger.log(LogLevel::DEBUG, "Running post-generate hooks.");
    if (auto res = hooks::postGenerate(config); !res) {
        catalyst::logger.log(LogLevel::ERROR, "Post-generate hook failed: {}", res.error());
        return res;
    }
    catalyst::logger.log(LogLevel::DEBUG, "Generate subcommand finished successfully.");
    return {};
}

namespace {
std::vector<std::string> intermediateTargets(catalyst::generate::buildwriters::BaseWriter &writer,
                                             const std::unordered_set<std::filesystem::path> &source_set) {
    catalyst::logger.log(LogLevel::DEBUG, "Generate subcommand invoked.");
    fs::path current_dir = fs::current_path();
    writer.addComment("Source File Compilation");
    std::vector<std::string> object_files;
    for (const auto &src : source_set) {
        fs::path relative_src_path = fs::relative(src, current_dir);
        std::string obj_name = relative_src_path.string();
        std::replace(obj_name.begin(), obj_name.end(), '/', '_');
        std::replace(obj_name.begin(), obj_name.end(), '\\', '_'); // For Windows paths
        obj_name = obj_name.substr(0, obj_name.find_last_of('.')) + ".o";
        object_files.push_back((fs::path{"obj"} / obj_name).string());
        writer.addBuild({object_files.back()},
                        ((src.extension() == ".c" || src.extension() == ".cu") ? "cc_compile" : "cxx_compile"),
                        {src.string()});
    }
    return object_files;
}

void finalTarget(const utils::yaml::Configuration &config,
                 const auto &object_files,
                 catalyst::generate::buildwriters::BaseWriter &writer) {
    catalyst::logger.log(LogLevel::DEBUG, "Generating final target.");
    // Build edge for the final target
    std::string type = config.getString("manifest.type").value_or("BINARY");
    std::string target_prefix;
    std::string target_suffix;
    std::string link_rule;

    if (type == "STATICLIB") {
        link_rule = "static_link";
#if defined(_WIN32)
        target_prefix = "";
        target_suffix = ".lib";
#else
        target_prefix = "lib";
        target_suffix = ".a";
#endif
    } else if (type == "SHAREDLIB") {
        link_rule = "shared_link";
#if defined(_WIN32)
        target_prefix = "";
        target_suffix = ".dll";
#elif defined(__APPLE__)
        target_prefix = "lib";
        target_suffix = ".dylib";
#else // Linux and other Unix-likes
        target_prefix = "lib";
        target_suffix = ".so";
#endif
    } else { // BINARY or default
        link_rule = "binary_link";
#if defined(_WIN32)
        target_suffix = ".exe";
#endif
    }

    std::string target_name = config.getString("manifest.name").value_or("name");
    fs::path target_path{target_prefix + target_name + target_suffix};
    catalyst::logger.log(LogLevel::DEBUG, "Final target name: {}", target_path.string());
    writer.addComment("Build edge for the final target");
    writer.addBuild({target_path.string()}, link_rule, object_files);

    // Default target
    writer.addComment("Default target to build");
    writer.addDefault(target_path.string());
}

void writeVariables(const catalyst::utils::yaml::Configuration &config,
                    catalyst::generate::buildwriters::BaseWriter &writer,
                    const std::vector<std::string> &enabled_features) {

    catalyst::logger.log(LogLevel::DEBUG, "Writing variables to build file.");
    std::string build_dir_str = config.getString("manifest.dirs.build").value_or("build");

    std::string cxxflags =
        std::format(R"({} -DCATALYST_BUILD_SYS=1 -DCATALYST_PROJ_NAME="{}" -DCATALYST_PROJ_VER="{}")",
                    config.getString("manifest.tooling.CXXFLAGS").value_or(""),
                    config.getString("manifest.name").value_or("name"),
                    config.getString("manifest.version").value_or("0.0.0"));
    std::string ccflags = std::format(R"({} -DCATALYST_BUILD_SYS=1 -DCATALYST_PROJ_NAME="{}" -DCATALYST_PROJ_VER="{}")",
                                      config.getString("manifest.tooling.CCFLAGS").value_or(""),
                                      config.getString("manifest.name").value_or("name"),
                                      config.getString("manifest.version").value_or("0.0.0"));
    std::string ldflags = "-Lcatalyst-libs";

    if (const char *vcpkg_root = std::getenv("VCPKG_ROOT"); vcpkg_root != nullptr) {
#if defined(_WIN32)
        const char *triplet = "x64-windows";
#elif defined(__APPLE__)
        const char *triplet = "x64-osx";
#else
        const char *triplet = "x64-linux";
#endif
        cxxflags += std::format(" -I{}", (fs::path(vcpkg_root) / "installed" / triplet / "include").string());
        ccflags += std::format(" -I{}", (fs::path(vcpkg_root) / "installed" / triplet / "include").string());
        ldflags += std::format(" -L{}", (fs::path(vcpkg_root) / "installed" / triplet / "lib").string());
    } else {
        logger.log(LogLevel::WARN, "VCPKG_ROOT environment variable is not defined.");
    }

    if (const auto &features_node = config.getRoot()["features"]; features_node && features_node.IsSequence()) {
        for (const auto &feature_map : features_node) {
            if (feature_map.IsMap()) {
                for (auto it = feature_map.begin(); it != feature_map.end(); ++it) {
                    auto feature = it->first.as<std::string>();
                    bool default_enabled = it->second.as<bool>();
                    bool explicitly_enabled =
                        std::find(enabled_features.begin(), enabled_features.end(), feature) != enabled_features.end();
                    bool explicitly_disabled =
                        std::find(enabled_features.begin(), enabled_features.end(), "no-" + feature) !=
                        enabled_features.end();

                    bool is_enabled = default_enabled;
                    if (explicitly_enabled) {
                        is_enabled = true;
                    } else if (explicitly_disabled) {
                        is_enabled = false;
                    }

                    std::string flag = std::format(" -DFF_{}__{}={}",
                                                   config.getString("manifest.name").value_or("name"),
                                                   feature,
                                                   is_enabled ? "1" : "0");
                    cxxflags += flag;
                    ccflags += flag;
                }
            }
            // reaching this is technically an error but we allow it
        }
    }

    std::vector<std::string> inc_dirs = config.getStringVector("manifest.dirs.include").value();
    for (const auto &inc_dir : inc_dirs) {
        cxxflags += std::format(" -I{}", fs::absolute(inc_dir).string());
        ccflags += std::format(" -I{}", fs::absolute(inc_dir).string());
    }

    std::string ldlibs;
    for (const auto &dep : config.getRoot()["dependencies"]) {
        auto find_dep_res = findDep(build_dir_str, dep);
        if (!find_dep_res) {
            catalyst::logger.log(LogLevel::ERROR, "{}", find_dep_res.error());
            continue;
        }
        auto [lib_path, inc_path, libs] = find_dep_res.value();
        ldflags += " " + lib_path;
        ldlibs += " " + libs;
        ccflags += " " + inc_path;
        cxxflags += " " + inc_path;
    }

    writer.addComment("Variables");
    writer.addVariable("cc", config.getString("manifest.tooling.CC").value_or("clang"));
    writer.addVariable("cxx", config.getString("manifest.tooling.CXX").value_or("clang++"));
    writer.addVariable("cxxflags", cxxflags);
    writer.addVariable("cflags", ccflags);
    writer.addVariable("ldflags", ldflags);
    writer.addVariable("ldlibs", ldlibs); // place compiled libraries here
}

void writeRules(catalyst::generate::buildwriters::BaseWriter &writer) {
    catalyst::logger.log(LogLevel::DEBUG, "Writing rules to build file.");
    writer.addComment("Rules for compiling");
    writer.addRule("cxx_compile", "$cxx $cxxflags -MMD -MF $out.d -c $in -o $out", "CXX $out", "$out.d", "gcc");
    writer.addRule("cc_compile", "$cc $cflags -MMD -MF $out.d -c $in -o $out", "CC $out", "$out.d", "gcc");

    writer.addComment("Rules for linking");
    writer.addRule("binary_link", "$cxx $in -o $out $ldflags $ldlibs", "LINK $out");
    writer.addRule("static_link", "ar rcs $out $in", "LINK $out");
    writer.addRule("shared_link", "$cxx -shared $in -o $out", "LINK $out");
}
} // namespace

} // namespace catalyst::generate
