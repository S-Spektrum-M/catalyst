#include "catalyst/hooks.hpp"
#include "catalyst/log-utils/log.hpp"
#include "catalyst/subcommands/generate.hpp"
#include "catalyst/yaml-utils/Configuration.hpp"
#include "yaml-cpp/node/node.h"

#include <expected>
#include <filesystem>
#include <fstream>
#include <stdexcept>
#include <string>
#include <sys/wait.h>
#include <unordered_set>
#include <vector>
#include <yaml-cpp/yaml.h>

namespace catalyst::generate {
namespace fs = std::filesystem;

void write_variables(const catalyst::YAML_UTILS::Configuration &config,
                     catalyst::generate::BuildWriters::BaseWriter &writer,
                     const std::vector<std::string> &enabled_features);
void write_rules(catalyst::generate::BuildWriters::BaseWriter &writer);
std::vector<std::string> intermediate_targets(catalyst::generate::BuildWriters::BaseWriter &writer,
                                              const std::unordered_set<fs::path> &source_set);
void final_target(const YAML_UTILS::Configuration &config,
                  const auto &object_files,
                  catalyst::generate::BuildWriters::BaseWriter &writer);

std::expected<void, std::string> action(const parse_t &parse_args) {
    catalyst::logger.log(LogLevel::DEBUG, "Generate subcommand invoked.");

    catalyst::logger.log(LogLevel::DEBUG, "Composing profiles.");
    YAML_UTILS::Configuration config;

    try {
        config = YAML_UTILS::Configuration(parse_args.profiles);
    } catch (std::runtime_error &err) {
        return std::unexpected(err.what());
    }

    catalyst::logger.log(LogLevel::DEBUG, "Running pre-generate hooks.");
    if (auto res = hooks::pre_generate(config); !res) {
        catalyst::logger.log(LogLevel::ERROR, "Pre-generate hook failed: {}", res.error());
        return res;
    }

    fs::path current_dir = fs::current_path();
    std::vector<std::string> relative_source_dirs, absolute_source_dirs;
    if (auto res = config.get_string_vector("manifest.dirs.source"); !res) {
        return std::unexpected("Unable to get value for manifest.dirs.source");
    } else {
        relative_source_dirs = res.value();
        for (const auto &dir : relative_source_dirs)
            absolute_source_dirs.push_back((current_dir / dir).string());
    }

    catalyst::logger.log(LogLevel::DEBUG, "Building source set.");
    auto source_set_res = build_source_set(absolute_source_dirs, parse_args.profiles);
    if (!source_set_res) {
        catalyst::logger.log(LogLevel::ERROR, "Failed to build source set: {}", source_set_res.error());
        return std::unexpected(source_set_res.error());
    }

    std::unordered_set<std::filesystem::path> source_set = source_set_res.value();

    fs::path build_dir = config.get_string("manifest.dirs.build").value();
    fs::path obj_dir = build_dir / "obj";

    catalyst::logger.log(LogLevel::DEBUG, "Creating object directory: {}", obj_dir.string());
    fs::create_directories(obj_dir);
    if (!fs::exists(obj_dir) || !fs::is_directory(obj_dir)) {
        catalyst::logger.log(LogLevel::ERROR, "Failed to create object directory: {}", obj_dir.string());
        return std::unexpected("Failed to create object directory: " + obj_dir.string());
    }

    std::string generator = config.get_string("meta.generator").value_or("cbe");
    std::string build_filename = (generator == "ninja") ? "build.ninja" : "catalyst.build";

    const fs::path buildfile_path = build_dir / build_filename;
    catalyst::logger.log(LogLevel::DEBUG, "Writing build file to: {}", buildfile_path.string());
    std::ofstream buildfile{buildfile_path};

    if (!buildfile) {
        return std::unexpected(std::format("Failed to open {} for writing", buildfile_path.string()));
    }

    auto generate_build = [&](BuildWriters::BaseWriter &writer) {
        writer.add_comment("Build file generated by Catalyst");
        write_variables(config, writer, parse_args.enabled_features);
        write_rules(writer);
        std::vector<std::string> object_files = intermediate_targets(writer, source_set);
        final_target(config, object_files, writer);
    };

    if (generator == "ninja") {
        BuildWriters::DerivedWriter<BuildWriters::TargetType::Ninja> writer(buildfile);
        generate_build(writer);
    } else {
        BuildWriters::DerivedWriter<BuildWriters::TargetType::CBE> writer(buildfile);
        generate_build(writer);
    }

    catalyst::logger.log(
        LogLevel::DEBUG, "Writing profile composition to: {}", (build_dir / "profile_composition.yaml").string());
    std::ofstream profile_comp_file{build_dir / "profile_composition.yaml"};
    if (!profile_comp_file) {
        return std::unexpected("Failed to open profile_composition.yaml for writing in " + build_dir.string());
    }
    profile_comp_file << config.get_root();

    catalyst::logger.log(LogLevel::DEBUG, "Running post-generate hooks.");
    if (auto res = hooks::post_generate(config); !res) {
        catalyst::logger.log(LogLevel::ERROR, "Post-generate hook failed: {}", res.error());
        return res;
    }
    catalyst::logger.log(LogLevel::DEBUG, "Generate subcommand finished successfully.");
    return {};
}

std::vector<std::string> intermediate_targets(catalyst::generate::BuildWriters::BaseWriter &writer,
                                              const std::unordered_set<std::filesystem::path> &source_set) {
    catalyst::logger.log(LogLevel::DEBUG, "Generating intermediate targets.");
    fs::path current_dir = fs::current_path();
    writer.add_comment("Source File Compilation");
    std::vector<std::string> object_files;
    for (const auto &src : source_set) {
        fs::path relative_src_path = fs::relative(src, current_dir);
        std::string obj_name = relative_src_path.string();
        std::replace(obj_name.begin(), obj_name.end(), '/', '_');
        std::replace(obj_name.begin(), obj_name.end(), '\\', '_'); // For Windows paths
        obj_name = obj_name.substr(0, obj_name.find_last_of('.')) + ".o";
        object_files.push_back((fs::path{"obj"} / obj_name).string());
        writer.add_build({object_files.back()},
                         ((src.extension() == ".c" || src.extension() == ".cu") ? "cc_compile" : "cxx_compile"),
                         {src.string()});
    }
    return object_files;
}

void final_target(const YAML_UTILS::Configuration &config,
                  const auto &object_files,
                  catalyst::generate::BuildWriters::BaseWriter &writer) {
    catalyst::logger.log(LogLevel::DEBUG, "Generating final target.");
    // Build edge for the final target
    std::string type = config.get_string("manifest.type").value_or("BINARY");
    std::string target_prefix, target_suffix, link_rule;

    if (type == "STATICLIB") {
        link_rule = "static_link";
#if defined(_WIN32)
        target_prefix = "";
        target_suffix = ".lib";
#else
        target_prefix = "lib";
        target_suffix = ".a";
#endif
    } else if (type == "SHAREDLIB") {
        link_rule = "shared_link";
#if defined(_WIN32)
        target_prefix = "";
        target_suffix = ".dll";
#elif defined(__APPLE__)
        target_prefix = "lib";
        target_suffix = ".dylib";
#else // Linux and other Unix-likes
        target_prefix = "lib";
        target_suffix = ".so";
#endif
    } else { // BINARY or default
        link_rule = "binary_link";
#if defined(_WIN32)
        target_suffix = ".exe";
#endif
    }

    std::string target_name = config.get_string("manifest.name").value_or("name");
    fs::path target_path{target_prefix + target_name + target_suffix};
    catalyst::logger.log(LogLevel::DEBUG, "Final target name: {}", target_path.string());
    writer.add_comment("Build edge for the final target");
    writer.add_build({target_path.string()}, link_rule, object_files);

    // Default target
    writer.add_comment("Default target to build");
    writer.add_default(target_path.string());
}
} // namespace catalyst::generate
