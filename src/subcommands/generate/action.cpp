#include "catalyst/hooks.hpp"
#include "catalyst/log-utils/log.hpp"
#include "catalyst/subcommands/generate.hpp"
#include "catalyst/yaml-utils/Configuration.hpp"
#include "yaml-cpp/node/node.h"
#include <expected>
#include <filesystem>
#include <fstream>
#include <stdexcept>
#include <string>
#include <sys/wait.h>
#include <unordered_set>
#include <vector>
#include <yaml-cpp/yaml.h>

namespace catalyst::generate {
namespace fs = std::filesystem;

void write_variables(const catalyst::YAML_UTILS::Configuration &config, std::ofstream &buildfile,
                     const std::vector<std::string> &enabled_features);
void write_rules(std::ofstream &buildfile);
std::vector<std::string> intermediate_targets(std::ofstream &buildfile, const std::unordered_set<fs::path> &source_set);
void final_target(const YAML_UTILS::Configuration &config, const auto &object_files, std::ofstream &buildfile);

std::expected<void, std::string> action(const parse_t &parse_args) {
    catalyst::logger.log(LogLevel::INFO, "Generate subcommand invoked.");

    catalyst::logger.log(LogLevel::INFO, "Composing profiles.");
    YAML_UTILS::Configuration config;

    try {
        config = YAML_UTILS::Configuration(parse_args.profiles);
    } catch (std::runtime_error &err) {
        return std::unexpected(err.what());
    }

    catalyst::logger.log(LogLevel::INFO, "Running pre-generate hooks.");
    if (auto res = hooks::pre_generate(config); !res) {
        catalyst::logger.log(LogLevel::ERROR, "Pre-generate hook failed: {}", res.error());
        return res;
    }

    fs::path current_dir = fs::current_path();
    std::vector<std::string> relative_source_dirs, absolute_source_dirs;
    if (auto res = config.get_string_vector("manifest.dirs.source"); !res) {
        return std::unexpected("Unable to get value for manifest.dirs.source");
    } else {
        relative_source_dirs = res.value();
        for (const auto &dir : relative_source_dirs)
            absolute_source_dirs.push_back((current_dir / dir).string());
    }

    catalyst::logger.log(LogLevel::INFO, "Building source set.");
    auto source_set_res = build_source_set(absolute_source_dirs, parse_args.profiles);
    if (!source_set_res) {
        catalyst::logger.log(LogLevel::ERROR, "Failed to build source set: {}", source_set_res.error());
        return std::unexpected(source_set_res.error());
    }

    std::unordered_set<std::filesystem::path> source_set = source_set_res.value();

    fs::path build_dir = config.get_string("manifest.dirs.build").value();
    fs::path obj_dir = build_dir / "obj";

    catalyst::logger.log(LogLevel::INFO, "Creating object directory: {}", obj_dir.string());
    fs::create_directories(obj_dir);
    if (!fs::exists(obj_dir) || !fs::is_directory(obj_dir)) {
        catalyst::logger.log(LogLevel::ERROR, "Failed to create object directory: {}", obj_dir.string());
        return std::unexpected("Failed to create object directory: " + obj_dir.string());
    }

    catalyst::logger.log(LogLevel::INFO, "Writing build file to: {}", (build_dir / "build.ninja").string());
    std::ofstream buildfile{build_dir / "build.ninja"};

    if (!buildfile) {
        return std::unexpected(
            std::format("Failed to open {} for writing", fs::path{build_dir / "build.ninja"}.string()));
    }

    buildfile << "# Ninja build file generated by Catalyst\n\n";

    write_variables(config, buildfile, parse_args.enabled_features);
    write_rules(buildfile);
    std::vector<std::string> object_files = intermediate_targets(buildfile, source_set);
    final_target(config, object_files, buildfile);

    catalyst::logger.log(LogLevel::INFO, "Writing profile composition to: {}",
                         (build_dir / "profile_composition.yaml").string());
    std::ofstream profile_comp_file{build_dir / "profile_composition.yaml"};
    if (!profile_comp_file) {
        return std::unexpected("Failed to open profile_composition.yaml for writing in " + build_dir.string());
    }
    profile_comp_file << config.get_root();

    catalyst::logger.log(LogLevel::INFO, "Running post-generate hooks.");
    if (auto res = hooks::post_generate(config); !res) {
        catalyst::logger.log(LogLevel::ERROR, "Post-generate hook failed: {}", res.error());
        return res;
    }
    catalyst::logger.log(LogLevel::INFO, "Generate subcommand finished successfully.");
    return {};
}

std::vector<std::string> intermediate_targets(std::ofstream &buildfile,
                                              const std::unordered_set<std::filesystem::path> &source_set) {
    catalyst::logger.log(LogLevel::INFO, "Generating intermediate targets.");
    fs::path current_dir = fs::current_path();
    buildfile << "# Source File Compilation\n";
    std::vector<std::string> object_files;
    for (const auto &src : source_set) {
        fs::path relative_src_path = fs::relative(src, current_dir);
        std::string obj_name = relative_src_path.string();
        std::replace(obj_name.begin(), obj_name.end(), '/', '_');
        std::replace(obj_name.begin(), obj_name.end(), '\\', '_'); // For Windows paths
        obj_name = obj_name.substr(0, obj_name.find_last_of('.')) + ".o";
        object_files.push_back((fs::path{"obj"} / obj_name).string());
        buildfile << "build " << object_files.back() << ": "
                  << ((src.extension() == ".c" || src.extension() == ".cu") ? "cc_compile" : "cxx_compile") << " "
                  << src.string() << "\n";
    }
    buildfile << "\n";
    return object_files;
}

void final_target(const YAML_UTILS::Configuration &config, const auto &object_files, std::ofstream &buildfile) {
    catalyst::logger.log(LogLevel::INFO, "Generating final target.");
    // Build edge for the final target
    std::string type = config.get_string("manifest.type").value_or("BINARY");
    std::string target_prefix, target_suffix, link_rule;

    if (type == "STATICLIB") {
        link_rule = "static_link";
#if defined(_WIN32)
        target_prefix = "";
        target_suffix = ".lib";
#else
        target_prefix = "lib";
        target_suffix = ".a";
#endif
    } else if (type == "SHAREDLIB") {
        link_rule = "shared_link";
#if defined(_WIN32)
        target_prefix = "";
        target_suffix = ".dll";
#elif defined(__APPLE__)
        target_prefix = "lib";
        target_suffix = ".dylib";
#else // Linux and other Unix-likes
        target_prefix = "lib";
        target_suffix = ".so";
#endif
    } else { // BINARY or default
        link_rule = "binary_link";
#if defined(_WIN32)
        target_suffix = ".exe";
#endif
    }

    std::string target_name = config.get_string("manifest.name").value_or("name");
    fs::path target_path{target_prefix + target_name + target_suffix};
    catalyst::logger.log(LogLevel::INFO, "Final target name: {}", target_path.string());
    buildfile << "# Build edge for the final target\n";
    buildfile << "build " << target_path.string() << ": " << link_rule;
    for (const auto &obj : object_files) {
        buildfile << " " << obj;
    }
    buildfile << "\n\n";

    // Default target
    buildfile << "# Default target to build";
    buildfile << "default " << target_path.string() << "\n";
}
} // namespace catalyst::generate
